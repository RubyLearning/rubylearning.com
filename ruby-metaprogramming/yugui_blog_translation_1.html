<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Ruby Metaprogramming</title>
<meta name="keywords" content="ruby metaprogramming,ruby programming,metaprogramming" />
<meta name="description" content="RubyLearning.org" />
<link rel="icon" type="image/ico" href="http://rubylearning.com/images/favicon.ico" />
<link rel="stylesheet" href="html/static/style.css" type="text/css" media="screen" />
<script type="text/javascript" src="html/static/code_highlighter.js"></script>
<script type="text/javascript" src="html/static/code_highlighter_ruby.js"></script>
<base href="http://ruby-metaprogramming.rubylearning.com/" />
<!-- Google +1 button code -->
<link rel="canonical" href="http://ruby-metaprogramming.rubylearning.com/yugui_blog_translation_1.html" />
<script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>

<!-- Google Analytics code -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-59044-10']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<!-- Google Analytics code ends -->
</head>
<body>
<p>This is a translation in English of <a href="http://yugui.jp/articles/541">Yugui's blog</a> written in Japanese.
<br /><br /></p>

<hr/>

<p>Dec. 14th, 2006</p>

<h1>Compare Ruby Callable Objects, Part 1</h1>
                <!-- Place this tag where you want the +1 button to render -->
				<div class="g-plusone"></div>
				<script type="text/javascript">
				  window.___gcfg = {
				    lang: 'en-US'
				  };

				  (function() {
				    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
				    po.src = 'https://apis.google.com/js/plusone.js';
				    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
				  })();
				</script>

<p><br /><br />
Ruby has various callable objects, <a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=Method">Method</a>, <a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=UnboundMethod">UnboundMethod</a> and <a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=Proc">Proc</a>.</p>

<p><a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=Continuation">Continuation</a> is slightly different, but pretty close as the object which remembers execution context.</p>

<p>In "<a href="http://www.amazon.co.jp/Ruby-Way%E2%80%95Ruby%E9%81%93%E3%81%B8%E3%81%AE%E6%8B%9B%E5%BE%85-%E3%83%8F%E3%83%AB-%E3%83%95%E3%83%AB%E3%83%88%E3%83%B3/dp/4798102288%3FSubscriptionId%3D1RAGVKTC911XF3D44E02%26tag%3Didm-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798102288">The Ruby Way</a>", author says that it's not surprisingly. But I was surprised.</p>

<p>Also they have slightly different behaviors. There ain't no justice.
It might be handy, though.</p>

<p><br />
This time I'd like to look at a brief overview.</p>

<p><br /><br /></p>

<h2>Normal method</h2>

<p>We usually define a method with def keyword.</p>

<pre><code class="ruby">
class C
  def greeting(arg)
    puts "C#greeting reveived #{arg}"
  end

  def iterator
    yield 'iterator 1st'
    yield 'iterator 2nd'
    yield 'iterator 3rd'
  end

  local = 1
  def ref_local
    puts local
  end
end

obj = C.new

# We can call it normally.
obj.greeting 1     # => C#greeting received 1

# Ruby checks number of arguments.
obj.greeting 1, 2
  # => ArgumentError: wrong number of arguments (2 for 1)

# Ruby can call a method with a block. Good feature. Pretty good!
obj.iterator do |item|
  puts item
end
  # => iterator 1st
  #    iterator 2nd
  #    iterator 3rd


# We can not access local variables outside of def block.
# In JavaScript, we can. So, not a good feeling.
obj.ref_local
  # => NameError: undefined local variable or method 'local' for #&lt;C:0x5e1b8&gt;
</code></pre>

<h2>Method Object</h2>

<p>Ruby's method is able to become an object. That is called Method object which represents a callable object.</p>

<p>Method objects are created by Object#method method. It is invoked with a method name in string or symbol as an argument.</p>

<pre><code class="ruby">
greeting = obj.method(:greeting)
</code></pre>

<p>We can call methods without parentheses. But that is the reason it's impossible to write <code class="ruby">obj.greeting</code> to creat Method object as like as in JavaScript or Python.</p>

<p>There is no natural way to represent Method object. That is one of the reasons Ruby's methods are not first-class objects.</p>

<p>We can not use <code class="ruby">greeting</code> as same as a normal method. This <code class="ruby">greeting</code> is a local variable. But Ruby looks for the method name in the name space for methods. Then it occurs NoMethodError. </p>

<p>In Ruby, variables and methods don't share the same name space.</p>

<pre><code class="ruby">
greeting(1)  # => NoMethodError: undefined method `greeting' for main:Object
</code></pre>

<p>In fact, if you write <code class="ruby">greeting</code> with no arguments, the error for wrong number of arguments doesn't occur.</p>

<p>As you know, Ruby accepts that as an expression includes only a local variable <code class="ruby">greeting</code>.</p>

<pre><code class="ruby">
greeting     # => #&lt;Method: C#greeting&gt;
</code></pre>

<p>We use call or [] to invoke Method object. The [] is overridden to invoke the object in the nealy same way as normal method call with parentheses.</p>

<pre><code class="ruby">
# greeting.call 1 # => C#greeting received 1
# greeting[1]     # => C#greeting received 1
</code></pre>

<p>Ruby checks the number of arguments.</p>

<pre><code class="ruby">
greeting[1, 2]  # => ArgumentError: wrong number of arguments (2 for 1)
</code></pre>

<p>Also possible with a block.</p>

<pre><code class="ruby">
iterator = obj.method(:iterator)
iterator.call do |item|
  puts item
end
  # => iterator 1st
  #    iterator 2nd
  #    iterator 3rd
</code></pre>

<h2>Calling Syntax</h2>

<p>Can't invoke by normal way is disturbing. Matz has also concerned about that. </p>

<p>For instance: <a href="http://www.rubyist.net/~matz/20040910.html#p02">Omit call</a>. Back and forth in Ruby 1.9.</p>

<p><br /><br /></p>

<h2>parse.y version 1.372</h2>

<p>Changelog: <a href="http://www.ruby-lang.org/cgi-bin/cvsweb.cgi/ruby/parse.y.diff?r1=1.381;r2=1.382;f=h">parse.y version 1.372</a>. As local variable with parentheses, Ruby converts it to <code class="ruby">call</code> implicitly.</p>

<pre><code class="ruby">
greeting("v 1.372")    # => C#greeting received v 1.372
greeting "v 1.372"     # => C#greeting received v 1.372
</code></pre>

<p>It's possible to omit parentheses. Oh, fantastic!</p>

<p><br /><br /></p>

<h2>parse.y version 1.382</h2>

<p>Changelog: <a href="http://www.ruby-lang.org/cgi-bin/cvsweb.cgi/ruby/parse.y.diff?r1=1.381;r2=1.382;f=h">parse.y version 1.382</a>. Stop implicit conversion. Also need to add parentheses to local variable.</p>

<pre><code class="ruby">
(greeting)("v 1.382")   # => C#greeting received v 1.382
</code></pre>

<p>I guess this syntax came from function pointer in C. Because MRI Matz's Ruby Implementation) is written with K &amp; R style. In fact, both side parentheses are impossible to omit.</p>

<pre><code class="ruby">
greeting(1)   # => undefined method `greeting' for main:Object (NoMethodError)

(greeting) 1  # => parse error
</code></pre>

<p><br /><br /></p>

<h2>After all, stop again</h2>

<p>Changelog: <a href="http://www.ruby-lang.org/cgi-bin/cvsweb.cgi/ruby/parse.y.diff?r1=1.441;r2=1.442;f=h">parse.y version 1.442</a>. This syntax was gone.</p>

<pre><code class="ruby">
(greeting)(1)  # => parse error, expecting `$'
</code></pre>

<p><br /><br /></p>

<h2>Comparison to <code class="ruby">__send__</code></h2>

<p>Method object calling syntax is not cool. But in fact, it's not so comfortable in Ruby.</p>

<p>Because we don't usually use it in the first place.</p>

<p>If we want to change the method, it's easy to hold the message and send it to the object with <code class="ruby">__send__</code> method.</p>

<pre><code class="ruby">
msg1 = [:greeting, 1]
msg2 = [:greeting, "Hello"]
msg3 = [:inspect]

obj.__send__(*msg1) # => C#greeting reveived 1
obj.__send__(*msg2) # => C#greeting reveived Hello
obj.__send__(*msg3) # => "#&lt;C:0x2aa33c&gt;"
</code></pre>

<p>Method object holds the code of the method. This is an advantage.</p>

<p>As you creat Method object, you can use the code of the method even if the original method was edited or deleted.</p>

<pre><code class="ruby">
greeting = obj.method(:greeting)
class C
  def greeting(arg)
     puts "Yet another ruby hacker"
  end
end

obj.greeting("test")  # => Yet another ruby hacker
greeting.call("test") # => C#greeting received test

class C
  remove_method :greeting
end

obj.greeting("test")
    # => NoMethodError: undefined method `greeting' for #&lt;C:0x2aa33c&gt;
greeting.call("test")
    # => C#greeting received test
</code></pre>

<p>On the other hand, <code class="ruby">__send__</code> metod holds the message (method name) for the object and dispatches that in each case. So, if you edit the method, it'll be affected.</p>

<p>Method object holds the code of the method and the method dispatching will not happen.</p>

<p>It had already happened when <code class="ruby">Object#method</code> was called. Hence it'll be executed by the previous definition, even if after edited. </p>

<p><br /><br /></p>

<h2>UnboundMethod</h2>

<p><code class="ruby">Method</code> is an object looks like pairing the method definition and the receiver. <code class="ruby">UnboundMethod</code> is an object pulled the receiver out.</p>

<p><code class="ruby">Method</code> object is close to <code class="ruby">delegate</code> in C#. <code class="ruby">UnboundMethod</code> object is closest to the member function pointer in C++. You implement a kind of stuff <code class="ruby">Method</code> by using a member function pointer like Functor of boost in C++.</p>

<p><code class="ruby">UnboundMethod</code> is created by <code class="ruby">Module#instance_method</code> or <code class="ruby">Method#unbind</code>.</p>

<pre><code class="ruby">
u_greeting = greeting.unbind
u_iterator = C.instance_method(:iterator)
</code></pre>

<p><code class="ruby">self</code> is around every corner in Ruby program. Ruby always sends a message to the object even if it looks like a function. So, it's impossible to execute <code class="ruby">UnboudMethod</code> without the receiver.</p>

<p><code class="ruby">UnboundMethod</code> has the <code class="ruby">call</code> and <code class="ruby">[]</code> methods. But probably, they are legacies in Ruby 1.6 when <code class="ruby">UnboundMethod</code> was a subclass of <code class="ruby">Method</code>. TypeError will happen if you call <code class="ruby">call</code> and <code class="ruby">[]</code> anyways.</p>

<p>So no choice, you can call it after setting the receiver with <code class="ruby">UnboundMethod#bind</code>.</p>

<p>You can use it in the same way because <code class="ruby">UnboundMethod#bind</code> returns Method object.</p>

<pre><code class="ruby">
iterator2 = u_iterator.bind(C.new)
iterator2.call do |item|
  puts item
end
</code></pre>

<p>You can not bind the UnboundMethod to the instance which belongs to the different class.</p>

<p>If it'd be possible to copy a method from a class to another class by using <code class="ruby">UnboundMethod</code>, I guess it's useful. But in fact,</p>

<pre><code class="ruby">
u_iterator.bind(OtherClass.new)
</code></pre>

<p>TypeError will happen. </p>

<p>Well, it may be risky to copy, because the method implemented in C is severe for type checking.</p>

<p>It's almost obvious to select <code class="ruby">Method</code> or <code class="ruby">UnboundMethod</code> to use. </p>

<p>Method is used to carry around <code class="ruby">self</code>. UnboundMethod is used to decide <code class="ruby">self</code> at the point of execution.</p>

<p>You need an instance object to create Method object, but it's possible to create UnboundMethod object from Class object.</p>

<p>By the way, Method and UnboudMethod are both implemented as <code class="ruby">struct METHOD</code> inside Ruby. The difference is just only not using the pointer for <code class="ruby">self</code>.</p>

<p><br /><br /></p>

<h2>Normal Proc</h2>

<p>Okay, next is Proc. </p>

<p>Proc object is an object which hold a code snippet. It is usually created with a block. It is created by Proc.new or Kernel#lambda. They are synonyms. </p>

<p>They are methods which transform a given block to a Proc object.</p>

<p>Inside Ruby, there is a little bit different from Proc object and a block which is executed by method call. </p>

<p>For example, in Ruby older versions, about a global jump behaviour when it executes <code class="ruby">break</code> or <code class="ruby">retry</code>. </p>

<p><a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=Proc">This document</a> offers detailed information about Proc.</p>

<p>Proc is unconventional from Method or UnboundMethod. There is no base method. It's weak to belong to a particular object... But most important difference is that it's a <code class="ruby">closure</code>.</p>

<pre><code class="ruby">
def create_closure
  counter = 0
  Proc.new { p counter += 1 }
end

c = create_closure
c.call     # => 1
c.call     # => 2
c.call     # => 3
....
</code></pre>

<p>After passing through the <code class="ruby">create_closure</code> method, there is already no scope which the local variable <code class="ruby">counter</code> belongs to.</p>

<p>But Proc object remembers the local variable. You can access the local variable inside the Proc object untill the Proc object vanishes.</p>

<p>Proc object keeps the context for local variables. The context has been kept the status (condition) when the Proc object was created. The <code class="ruby">create_closure</code> holds a new independent context everytime.</p>

<pre><code class="ruby">
c1 = create_closure
c1.call     # => 1
c1.call     # => 2
c1.call     # => 3

c2 = create_closre
c2.call     # => 1
c2.call     # => 2
c1.call     # => 4
c1.call     # => 5
c1.call     # => 6
c1.call     # => 7
c2.call     # => 3
c1.call     # => 8
c2.call     # => 4
</code></pre>

<p>The <code class="ruby">counter</code> c1 refers to and another <code class="ruby">counter</code> c2 refers to are totally different things.</p>

<p>They are like instance variables.</p>

<p>So, what is the benefit? <a href="http://d.hatena.ne.jp/babie/20060217/p4">Currying</a> ?</p>

<p>Come to think of it, we don't write the code which operates Proc object itself so much.</p>

<p>But this is an example. If you want to make two objects share the variable, but don't want to use global variables or instance variables.</p>

<pre><code class="ruby">
def create_twin
 shared = 0
 return [
   Proc.new { p shared += 1 },
   Proc.new { p shared += 1 }
 ]
end

dee, dum = create_twin
hikaru, kaoru = create_twin

dee.call    # => 1
dum.call    # => 2; dee and dum share the shared

hikaru.call # => 1
kaoru.call  # => 2; hikaru and kaoru share the other shared
</code></pre>

<p>This technique is usual in Perl rather than in Ruby.</p>

<p>It may be said that one of the technique which defines private methods in JavaScript is the aplication of this technique.</p>

<p>If you work with Ajax, you'll experience to come to appreciate <code class="ruby">Closure</code> by yourself.</p>

<p>(2006-11-17: <a href="http://b.hatena.ne.jp/ma2/20061116#bookmark-3240099">ma2</a> suggested a bug in the above code. Now fixed.)</p>

<p>Proc takes arguments as same as Method. They will be passed along to the block arguments like this:</p>

<pre><code class="ruby">
sum = 0
acc = Proc.new{|num| p sum += num}

acc.call(3) # => 3
acc.call(2) # => 5
</code></pre>

<p><br /><br /></p>

<h2>Block Syntax</h2>

<p>I think we usally use Proc to implement a method with a block rather than writing <code class="ruby">Proc.new</code>.</p>

<pre><code class="ruby">
def iterator(a, b, &amp;block)
 ...
end
</code></pre>

<p>As you write a method in the above style and call the method with a block, the block (code snippet) will be convert to Proc object and assign to the block argument <code class="ruby">block</code>.</p>

<p>This is an example of the method which evaluate the block with context in eigenclass for particular object.</p>

<pre><code class="ruby">
def singleton_class_eval(&amp;block)
 (class &lt;&lt; self; self end).class_eval(&amp;block)
end
</code></pre>

<p>In the above example, this method just passes the block to class_eval. Hence, it may not seem to be so useful. But if you get a block as an object, you can handle it as you like.</p>

<p>We can have a big dream.</p>

<p><br /><br /></p>

<h2>DSL</h2>

<p>Rails is using much in the way, once it gets Proc objects and keeps them in the instance variables, then invokes them when needed.</p>

<p>As I said at RubyKaigi2006, the reason we can write declarative representations in Rails is - it separates between the time to execute method definition and the time to execute code block.</p>

<p>For example, <code class="ruby">if</code> option which is added to <code class="ruby">validation</code>,</p>

<pre><code class="ruby">
class UserRegistration &lt; ActiveRecord::Base
 validates_presence_of :phone, :if => Proc.new{|reg| reg.stage >= 1}
 ....
end
</code></pre>

<p>If the application has several windows for user registration and you don't want to enable <code class="ruby">validates_presence_of :phone</code> option on the first window, you can write like this, based on the assignment of page number to stage attribute preliminarily.</p>

<p>ActiveRecord holds Proc object which is passed as an argument. ActiveRecord invokes Proc object with the instance of UserRegistration each time the validation of UserRegistration is executed.</p>

<p>Proc.new is executed when the class defins. But the content of the block which was passed as the argument will be executed later.</p>

<p><br /><br /></p>

<h2>Calling Notation</h2>

<p>Proc object has <code class="ruby">[]</code> and <code class="ruby">call</code> to call the code which is held inside the Proc object. This is the same as Method and UnboundMethod. Proc object has also <code class="ruby">Proc#yield</code>.</p>

<p>[] and call don't check out the number of arguments as same as Method or UnboundMethod.</p>

<p>But yield doesn't check out the number of arguments.</p>

<p>This is the same of executing yield statement in the method with block. For example,</p>

<pre><code class="ruby">
100.times do
 print "Hello"
end
</code></pre>

<p>Kernel#times passes the value of counter to the block. But sometimes it is not used like this.</p>

<p>I guess this may be the reason yield doesn't check out the number of arguments. If I always have to write like this: <code class="ruby">100.times do |i|</code>, I hate it.</p>

<p>Proc#yield has a good spec.</p>

<p><br /><br /></p>

<h2>How to use Proc</h2>

<p>As already mentioned, most typical case to use Proc is when we impliment a method with block.</p>

<p>As like as the above <code class="ruby">create_twin</code> example, Proc as closure gives us some peace of mind.</p>

<p>Because local variables that Proc refers to are not be able to be refered by anything except the Proc after passing through the context in which the Proc was created.</p>

<p>So, there is no need to worry about overwriting.</p>

<p>After passing through create_twin, the counter will not be able to access except the pair of Procs.</p>

<p>Technically, there is a loophole. But no prob, you have to write explicit code.</p>

<p>If you want to do that with instance variables, it's not so easy. Because you can access any instance variables anywhere in the instance.</p>

<p>Name collision between class and sub-class is really the problem. It remains possible that Ruby 2.0 will solve the problem. But we can do nothing at present.</p>

<p>We can use external scope reference to closure, if you create a liblary you never know who use and how extend.</p>

<p><br /><br /></p>

<h2>Continuation</h2>

<p>Once you understand the concept about Continuation, it's so natural. But it's very difficult to explain.</p>

<p>I think it's easier to learn Continuation in Scheme rather than in Ruby.</p>

<p>I also couldn't use Ruby Continuation before reading <a href="http://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9ESCHEME-R-%E3%82%B1%E3%83%B3%E3%83%88-%E3%83%87%E3%82%A3%E3%83%B4%E3%82%A3%E3%82%B0/dp/4894712261%3FSubscriptionId%3D1RAGVKTC911XF3D44E02%26tag%3Didm-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4894712261">Programming Language SCHEME</a>.</p>

<p>Ruby supports Continuation. I think this is one of the aspects.</p>

<p>If I'm not mistaken, Parrot said that he implemented Continuation by seeing porting Ruby.</p>

<p>But there is a few cases using effectively. Matz also said "I could implement Continuation, so I just did." It doesn't seem to support positively.</p>

<p>Sasada is not enthusiastic to support Continuation in YARV. So it might not be possible to support in Ruby 2.0.</p>

<p>I hope not. So I always say please support Continuation when I see Sasada.</p>

<p>Continuation is an object which represents the process from here to end. You can use <code class="ruby">Kernel#callcc</code> to make Continuation objects.</p>

<pre><code class="ruby">
cont = nil
callcc {|c| cont = c }
puts :ok
exit
</code></pre>

<p>Now, let's consider the above code. </p>

<pre><code class="ruby">
# puts :ok
# exit
</code></pre>

<p>The callcc will evaluate a block with a block argument which is the above code, Continuation object.</p>

<p>In this case, the object is kept in the block.</p>

<p>What is useful? Well, if you call the Continuation object, you can always execute the process next step after callcc. In this case, the context for local variables are also kept.</p>

<p>In this above code, there is <code class="ruby">exit</code> to stop the program. To keep simple explanation about the <code class="ruby">process from here</code>.</p>

<p>But in practice, it's not so easy. Then Continuation is in it's element.</p>

<p>Okay, how about this code? I wrote the code for my presentation in RubyKaigi. Then fixed a bug.</p>

<pre><code class="ruby">
@cont = []
ActiveRecord::Base.transaction do
 catch :save_tx do
   collection.each do |item|
     ....
     callcc{|c| @cont.push c; throw :save_tx} if something?
     ....
   end
 end
end
unless @cont.empty?
 ActiveRecord::Base.transaction do
   @cont.pop.call
 end
end
</code></pre>

<p>ActiveRecord::Base.transaction is a method which does the following:</p>

<ul>
<li>Start a database transaction.</li>
<li>Evaluate a block.</li>
<li>If the block is executed successfully, the transaction will be commited.</li>
<li>But if not, it will be rollbacked recovery.</li>
</ul>

<p>But when condition is right, don't you want to commit at once, then continue the process as if there is nothing happen?</p>

<p>The above code is the code which has the function to commit at once.</p>

<ul>
<li>line 2: Start ActiveRecord::Base.transaction</li>
<li>line 3: Use catch for getting out the loop. This is the same as a labeled break in Java. It's useful to get out nested blocks or structures. It's the same like this:</li>
</ul>

<pre><code class="ruby">
save_tx:
 for (Object item : collection) {
    ....
 }
</code></pre>

<ul>
<li>line 4: Do database operation for each element of some collection.</li>
<li>line 6: If condition is right, execute callcc. The callcc creates a Continuation object with the code which will be executed if there is no callcc.</li>
</ul>

<p>Then evaluates the block.</p>

<ul>
<li>block save that into @cont</li>
<li><p>At Kernel#throw, get out the block to the label :save<em>tx which was created by :save</em>tx</p></li>
<li><p>line 9: After getting out the block, there is no code to execute. So, also get out ActiveRecord::Base.transaction block immediately. This is normal, hence ActiveRecord::Base.transaction will commit the transaction.</p></li>
<li><p>line 11: Well, @cont.empty? means each of collections were operated normally, but not callcc. Now, it's not empty. Because @cont was assigned Continuation object in the block of callcc.</p></li>
<li><p>line 12: Run ActiveRecord::Base.transaction which starts the following transaction:</p></li>
<li>line 13: Pull out an element from @count and call.</li>
<li><p>Continuation object popped from @count holds <code class="ruby">process from here</code>. So, if necessally it restores local variables and move to the next step of callcc (line 7).</p></li>
<li><p>Now in the block of collection.each. So, restart the process again (line 8).</p></li>
<li>If the something? is right, do the same thing again (line 6).</li>
<li>collection.each will be finished sooner or later (line 8).</li>
<li>line 10: Then, ActiveRecord::Base.transaction will commit the transaction.</li>
<li>line 11: This time, will finish the program, because @cont is empty.</li>
</ul>

<p>Confusing?
Yeah, I think so. If you are not expert, I recommend you to read the library <a href="http://www.rubyist.net/~matz/20040723.html#p01">Change CGI to FastCGI</a> written by Matz.</p>

<p><br /><br /></p>

<h2>How to call</h2>

<p>You can call Continuation object with [] or <code class="ruby">.call</code>. </p>

<p>It's callable and holds the context. So, Continuation is one of the members of Method/Proc group.</p>

<p>But it's very different from them. Continuation#call doesn't return any controls basically.</p>

<p>In fact, arguments for <code class="ruby">.call</code> or [] become the evaluated value of callcc as an Array format when it's called back. </p>

<p>It's possible to distinguish when executing callcc and when returning from Continuation#call.</p>

<p>It's also possible to give some information to the environment returned.</p>

<p>If you know C, I think it's like an return value of setjmp.</p>

<p><br /><br /></p>

<h2>How to use Continuation</h2>

<p>If you get used to Continuation, it's a natural concept. Continuation is the process from here to end. It's useful when you want to do something temporarily  and leave the process from here to end. </p>

<p>You can also do it with Thread. But I think Continuation is more natural than Thread. In fact, it's possible to implement Thread with Continuation.</p>

<p>Although, it's messy to implement the preemptive Thread.</p>

<p>I think there is no hesitation to decide using Continuation and Method/UnboundMethod/Proc. Continuation is a kind of character.</p>

<p><br /><br /></p>

<h2>Announcement</h2>

<p>Well, this is an introductory information, not main story.</p>

<p>But it's long, so decided to publish first.</p>

<p>Next time, I'll try to consider about these callable objects in a different point of view.</p></body></html>
